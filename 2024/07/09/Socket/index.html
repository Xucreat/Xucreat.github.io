<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"xucreat.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="socket 是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口TCP&#x2F;IP协议族包括运输层、网络层、链路层">
<meta property="og:type" content="article">
<meta property="og:title" content="Socket">
<meta property="og:url" content="https://xucreat.github.io/2024/07/09/Socket/index.html">
<meta property="og:site_name" content="BoBoo">
<meta property="og:description" content="socket 是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口TCP&#x2F;IP协议族包括运输层、网络层、链路层">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xucreat.github.io/Socket/TCP_IP%E5%8D%8F%E8%AE%AE.png">
<meta property="og:image" content="https://xucreat.github.io/Socket/Pasted%20image%2020231008215816.png">
<meta property="og:image" content="https://xucreat.github.io/Socket/Pasted%20image%2020231106151100.png">
<meta property="og:image" content="https://xucreat.github.io/Socket/Pasted%20image%2020231106172759.png">
<meta property="og:image" content="https://xucreat.github.io/Socket/Pasted%20image%2020231107145105.png">
<meta property="og:image" content="https://xucreat.github.io/Socket/Pasted%20image%2020231107150503.png">
<meta property="og:image" content="https://xucreat.github.io/Socket/Pasted%20image%2020231108214814.png">
<meta property="article:published_time" content="2024-07-08T16:24:48.000Z">
<meta property="article:modified_time" content="2024-07-08T16:57:01.861Z">
<meta property="article:author" content="MandyX">
<meta property="article:tag" content="socket">
<meta property="article:tag" content="TCP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xucreat.github.io/Socket/TCP_IP%E5%8D%8F%E8%AE%AE.png">


<link rel="canonical" href="https://xucreat.github.io/2024/07/09/Socket/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://xucreat.github.io/2024/07/09/Socket/","path":"2024/07/09/Socket/","title":"Socket"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Socket | BoBoo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">
      <img class="custom-logo-image" src="/uploads/custom-logo.png" alt="BoBoo">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">BoBoo</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">BoBoo's</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-folder fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#socket-%E6%98%AF%E5%BA%94%E7%94%A8%E5%B1%82%E4%B8%8ETCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%AD%E9%97%B4%E8%BD%AF%E4%BB%B6%E6%8A%BD%E8%B1%A1%E5%B1%82%EF%BC%8C%E5%AE%83%E6%98%AF%E4%B8%80%E7%BB%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.</span> <span class="nav-text">socket 是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Socket%E7%BC%96%E7%A8%8B%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">Socket编程的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E7%BD%91%E7%BB%9C%E4%B8%AD%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="nav-number">2.1.</span> <span class="nav-text">1、网络中进程间如何通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A6%82%E4%BD%95%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">1)如何唯一标识一个进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSocket%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">2、什么是Socket？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81socket%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.</span> <span class="nav-text">3、socket的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-socket-%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.1.</span> <span class="nav-text">3.1 .socket()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-bind-%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.2.</span> <span class="nav-text">3.2.bind()函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-bind-%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">3.2.1 bind()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">3.2.2.网络字节序和主机字节序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%EF%BC%89%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F-%E5%B8%B8%E8%AF%B4%E7%9A%84%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F-%EF%BC%9A"><span class="nav-number">2.3.2.2.1.</span> <span class="nav-text">1）主机字节序(常说的大端和小端模式)：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%EF%BC%89%E5%A4%A7%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">2.3.2.2.2.</span> <span class="nav-text">2）大端字节序和小端字节序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%EF%BC%89%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%9A"><span class="nav-number">2.3.2.2.3.</span> <span class="nav-text">3）网络字节序：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-accept-%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.3.</span> <span class="nav-text">3.4.accept()函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-accept"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">3.4.1.accept()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-1-%E5%8C%BA%E5%88%86%E4%B8%A4%E7%A7%8D%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">2.3.3.1.1.</span> <span class="nav-text">3.4.1.区分两种套接字</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E7%9B%91%E5%90%AC%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">2.3.3.1.1.1.</span> <span class="nav-text">1)监听套接字</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2%EF%BC%89%E8%BF%9E%E6%8E%A5%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">2.3.3.1.1.2.</span> <span class="nav-text">2）连接套接字</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-read-%E3%80%81write-%E7%AD%89%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.4.</span> <span class="nav-text">3.5.read()、write()等函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-read-%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">3.4.1.read()函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-close-%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.5.</span> <span class="nav-text">3.6.close()函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Socket%E4%B8%ADTCP%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">4.Socket中TCP的建立（三次握手）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-TCP"><span class="nav-number">2.4.1.</span> <span class="nav-text">4.1.TCP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">2.4.2.</span> <span class="nav-text">4.2.三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">4.2.1.三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88SYN%EF%BC%89"><span class="nav-number">2.4.2.1.1.</span> <span class="nav-text">1) 第一次握手（SYN）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88SYN-ACK%EF%BC%89"><span class="nav-number">2.4.2.1.2.</span> <span class="nav-text">2)第二次握手（SYN-ACK）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88ACK%EF%BC%89"><span class="nav-number">2.4.2.1.3.</span> <span class="nav-text">3)第三次握手（ACK）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-SYN%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">4.2.2.SYN标志位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E4%B8%8D%E5%8F%AF%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">4.2.3.不可是两次握手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E9%87%8A%E6%94%BE"><span class="nav-number">2.4.3.</span> <span class="nav-text">5.TCP连接的终止(四次挥手四次握手释放)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">5.1.TCP四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%EF%BC%89%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88-FIN-Seq-x%EF%BC%89"><span class="nav-number">2.4.3.1.1.</span> <span class="nav-text">1）第一次挥手（[FIN], Seq &#x3D; x）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%EF%BC%89%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B-ACK-ACK-x-1"><span class="nav-number">2.4.3.1.2.</span> <span class="nav-text">2）第二次挥手 ([ACK], ACK &#x3D; x + 1)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%EF%BC%89%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B-FIN-Seq-y"><span class="nav-number">2.4.3.1.3.</span> <span class="nav-text">3）第三次挥手 ([FIN], Seq &#x3D; y)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%EF%BC%89%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-ACK-ACK-y-1"><span class="nav-number">2.4.3.1.4.</span> <span class="nav-text">4）第四次挥手 ([ACK], ACK &#x3D; y + 1)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2%E4%B8%8D%E8%83%BD%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">5.2不能三次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E9%87%8D%E8%A6%81%E5%AD%97%E6%AE%B5"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">5.3.重要字段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.5.</span> <span class="nav-text">6、实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PS%EF%BC%9A"><span class="nav-number">2.6.</span> <span class="nav-text">PS：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81IPv4%E5%9C%B0%E5%9D%80"><span class="nav-number">2.6.1.</span> <span class="nav-text">1、IPv4地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81IPv6%E5%9C%B0%E5%9D%80"><span class="nav-number">2.6.2.</span> <span class="nav-text">2、IPv6地址</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MandyX</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Xucreat" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Xucreat" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xucreat.github.io/2024/07/09/Socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MandyX">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoBoo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Socket | BoBoo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Socket
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-07-09 00:24:48 / 修改时间：00:57:01" itemprop="dateCreated datePublished" datetime="2024-07-09T00:24:48+08:00">2024-07-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Socket/" itemprop="url" rel="index"><span itemprop="name">Socket</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="socket-是应用层与TCP-IP协议族通信的中间软件抽象层，它是一组接口"><a href="#socket-是应用层与TCP-IP协议族通信的中间软件抽象层，它是一组接口" class="headerlink" title="socket 是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口"></a>socket 是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口</h1><p>TCP&#x2F;IP协议族包括运输层、网络层、链路层</p>
<span id="more"></span>
<p><img src="/Socket/TCP_IP%E5%8D%8F%E8%AE%AE.png" alt="My Image"></p>
<h1 id="Socket编程的工作原理"><a href="#Socket编程的工作原理" class="headerlink" title="Socket编程的工作原理"></a>Socket编程的工作原理</h1><p><img src="/Socket/Pasted%20image%2020231008215816.png" alt="alt text"></p>
<ul>
<li><p>服务端先初始化Socket ,然后与端口绑定（bind), 对端口进行监听(listen),  调用accept阻塞, 直到有客户端连接</p>
</li>
<li><p>客户端初始化一个Socket,  然后连接服务器(connect), 连接成功–&gt;连接建立<br>此时客户端向服务端发送数据请求–&gt;服务端接收请求并处理请求, 并把回应数据发送给客户端–&gt;客户端读取数据–&gt;关闭连接<br><em>一次交互结束</em></p>
</li>
</ul>
<h2 id="1、网络中进程间如何通信"><a href="#1、网络中进程间如何通信" class="headerlink" title="1、网络中进程间如何通信"></a>1、网络中进程间如何通信</h2><p>ps：本地的进程间通信（IPC）方式：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<h3 id="1-如何唯一标识一个进程"><a href="#1-如何唯一标识一个进程" class="headerlink" title="1)如何唯一标识一个进程"></a>1)如何唯一标识一个进程</h3><p><strong>网络层的“ip地址”</strong>   可以<strong>唯一</strong>标识网络中的<strong>主机</strong>，而<strong>传输层的“协议+端口”</strong> 可以唯一标识主机中的<strong>应用程序（进程</strong>）</p>
<p>利用三元组（<strong>ip地址，协议，端口</strong>）标识网络的进程–&gt;网络中的进程通信就可以利用这个标志与其它进程进行交互。</p>
<p>使用TCP&#x2F;IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）来实现网络进程之间的通信</p>
<h2 id="2、什么是Socket？"><a href="#2、什么是Socket？" class="headerlink" title="2、什么是Socket？"></a>2、什么是Socket？</h2><p>socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读&#x2F;写IO、打开、关闭）</p>
<p><font size=2>Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，<strong>它是一组接口</strong>。</font><br><font size=2>socket (门面模式) 将TCP&#x2F;IP协议族隐藏在接口后面–&gt;去组织数据，以符合指定的协议</font></p>
<hr>
<h2 id="3、socket的基本操作"><a href="#3、socket的基本操作" class="headerlink" title="3、socket的基本操作"></a>3、socket的基本操作</h2><h3 id="3-1-socket-函数"><a href="#3-1-socket-函数" class="headerlink" title="3.1 .socket()函数"></a>3.1 .socket()函数</h3><p><code>int socket(int domain, int type, int protocol);</code></p>
<ul>
<li><p><strong>domain</strong>: 协议域，又称为协议族（family）。<br> <font size=2>常用的协议族有 AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。</font><br>协议族决定<strong>socket的地址类型，在通信中必须采用对应的地址</strong>(<font size=2>如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</font>)</p>
</li>
<li><p><strong>type</strong>：指定socket类型。<br><font size=2>常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等</font></p>
</li>
<li><p><strong>protocol</strong>：指定协议。<br><font size=2>常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</font></p>
</li>
</ul>
<p><em>ps:<br>1)并不是上面的type和protocol可以随意组合，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议</em></p>
<p><em>2)调用socket创建一个socket时，返回的socket描述字存在于协议族空间中，但无具体地址。要赋给其一个地址，需要调用 bind() 函数，否则就当调用connect()、listen()时，系统自动随机分配一个端口</em></p>
<h3 id="3-2-bind-函数"><a href="#3-2-bind-函数" class="headerlink" title="3.2.bind()函数"></a>3.2.bind()函数</h3><h4 id="3-2-1-bind-函数"><a href="#3-2-1-bind-函数" class="headerlink" title="3.2.1 bind()函数"></a>3.2.1 bind()函数</h4><p>(将一个地址族中的特定地址赋给socket)<br><font size=2 color='green'>e.g.对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</font><br><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p>
<ul>
<li><strong>sockfd</strong>: 即socket描述字，它是通过socket()函数创建，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个地址。</li>
<li><strong>addr:</strong> 一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据创建socket时的地址协议族的不同而不同<br><font size=2 color='green'>e.g.如ipv4对应的是：</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t    sin_family; /* address family: AF_INET */</span><br><span class="line">    in_port_t      sin_port;   /* port in network byte order */</span><br><span class="line">    struct in_addr sin_addr;   /* internet address */</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* Internet address. */</span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    uint32_t       s_addr;     /* address in network byte order */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<font size=2 color='green'>e.g.ipv6对应的是：</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in6 &#123; </span><br><span class="line">    sa_family_t     sin6_family;   /* AF_INET6 */ </span><br><span class="line">    in_port_t       sin6_port;     /* port number */ </span><br><span class="line">    uint32_t        sin6_flowinfo; /* IPv6 flow information */ </span><br><span class="line">    struct in6_addr sin6_addr;     /* IPv6 address */ </span><br><span class="line">    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ </span><br><span class="line">&#125;; </span><br><span class="line">struct in6_addr &#123; </span><br><span class="line">    unsigned char   s6_addr[16];   /* IPv6 address */ </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>addrlen</strong>：地址的长度。</li>
</ul>
<p>服务器在启动的时候会绑定一个地址(ip地址＋端口号), 用于提供服务，而客户则可以通过该地址连接服务器；</p>
<p>客户端不用指定，由系统<strong>自动分配</strong>一个端口号和自身的ip地址组合。<br>–&gt;服务器端在调用 listen() 之前会调用bind()<font size=2 color='green'>赋给其一个地址</font>, 但客户端则不用, 而是在connect()时有系统随机生成一个</p>
<h4 id="3-2-2-网络字节序和主机字节序"><a href="#3-2-2-网络字节序和主机字节序" class="headerlink" title="3.2.2.网络字节序和主机字节序"></a>3.2.2.网络字节序<strong>和</strong>主机字节序</h4><p>是<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&spm=1001.2101.3001.7020">计算机网络</a>中常用的两种<strong>数据存储格式</strong>。</p>
<p>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p>
<h5 id="1）主机字节序-常说的大端和小端模式-："><a href="#1）主机字节序-常说的大端和小端模式-：" class="headerlink" title="1）主机字节序(常说的大端和小端模式)："></a>1）<strong>主机字节序</strong>(常说的大端和小端模式)：</h5><ul>
<li>指的是<u>在计算机内部存储数据</u>时采用的字节排序方式。<br>不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。</li>
</ul>
<h5 id="2）大端字节序和小端字节序"><a href="#2）大端字节序和小端字节序" class="headerlink" title="2）大端字节序和小端字节序"></a>2）大端字节序和小端字节序</h5><p>a) Little-Endian: 低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>b) Big-Endian: 就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p>
<h5 id="3）网络字节序："><a href="#3）网络字节序：" class="headerlink" title="3）网络字节序："></a>3）<strong>网络字节序</strong>：</h5><p>指的是一种标准的字节序，规定了<u>数据在网络数据传输</u>中采用的字节序，</p>
<ul>
<li>即<u>大端字节序</u>(4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。)，</li>
<li>也被称为网络序（Network Byte Order）(<strong>由于TCP&#x2F;IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序</strong>).<br>理由是因为不同的机器可能采用不同的主机字节序，<em>而<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1&spm=1001.2101.3001.7020">网络通信</a>必须使用统一的字节序，这样才能保证不同系统之间的通信正常进行。</em></li>
</ul>
<p><font color='red'>在将一个地址绑定到socket的时候，请<u>先将主机字节序转换成为网络字节序</u>，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。</font><br>请谨记对主机字节序不要做任何假定，务必<u>将其转化为网络字节序再赋给socket</u>。</p>
<h3 id="3-4-accept-函数"><a href="#3-4-accept-函数" class="headerlink" title="3.4.accept()函数"></a>3.4.accept()函数</h3><h4 id="3-4-1-accept"><a href="#3-4-1-accept" class="headerlink" title="3.4.1.accept()"></a>3.4.1.accept()</h4><p>accept默认会阻塞进程，直到有一个客户连接建立后返回，<br><strong>返回</strong>的是一个<em>新可用的套接字</em>，这个套接字<font color='green'>(已连接socket描述字)</font>是连接套接字。</p>
<p>TCP服务端依次调用socket()、bind()、listen()–&gt;监听指定的socket地址。<br>TCP客户端依次调用socket()、connect()–&gt;向TCP服务端发送一个连接请求。<br>TCP服务器监听到该请求–&gt;调用accept()函数接收请求–&gt;连接建立<br>开始网络I&#x2F;O操作 (类同于普通文件的读写I&#x2F;O操作)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); //返回连接connect_fd</span><br></pre></td></tr></table></figure>
<ul>
<li><p>sockfd: 监听套接字–&gt;监听一个端口<font color='green'>(服务器在启动的时候会绑定一个地址(ip地址＋端口号), 用于提供服务)</font>。当一个客户与服务器连接时，使用这个端口号，而这个端口号正与这个套接字关联。</p>
</li>
<li><p>addr: 结果参数–&gt;接受一个返回值,该返回值指定客户端的地址(<font size = 2>这个地址是通过某个地址结构来描述的，用户应该知道这一个什么样的地址结构。如果对客户的地址不感兴趣，那么可以把这个值设置为NULL</font>)</p>
</li>
<li><p>len: 结果参数，接受 addr 结构的大小，指明其所占有的字节个数，也可被设置为NULL</p>
</li>
<li><p>accept成功返回，则服务器与客户正确建立连接，此时服务器<u>通过accept返回的套接字(依然使用与监听套接字 sockfd() 相同的端口号)来完成与客户的通信。</u></p>
</li>
</ul>
<h5 id="3-4-1-区分两种套接字"><a href="#3-4-1-区分两种套接字" class="headerlink" title="3.4.1.区分两种套接字"></a>3.4.1.区分两种套接字</h5><h6 id="1-监听套接字"><a href="#1-监听套接字" class="headerlink" title="1)监听套接字"></a>1)监听套接字</h6><p> 监听套接字正如 accept 的参数 sockfd ，<em>调用 listen() 函数</em>–&gt;<em>服务器开始调用socket()函数生成</em>的，称为监听socket描述字(监听套接字)</p>
<h6 id="2）连接套接字"><a href="#2）连接套接字" class="headerlink" title="2）连接套接字"></a>2）连接套接字</h6><p>一个套接字会从主动连接的套接字变身为一个监听套接字；而accept函数返回的是已连接socket描述字(一个连接套接字)，它代表着一个网络已经存在的点点连接。</p>
<hr>
<p>一个服务器通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。<br>内核为每个由服务器进程接受的客户连接 创建了<font color='green'>(通过accept()函数的返回值) </font>一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<p>连接套接字socketfd_new 并没有占用新的端口与客户端通信，依然使用的是与监听套接字socketfd一样的端口号</p>
<h3 id="3-5-read-、write-等函数"><a href="#3-5-read-、write-等函数" class="headerlink" title="3.5.read()、write()等函数"></a>3.5.read()、write()等函数</h3><p>服务器与客户已建立连接，可以调用网络I&#x2F;O进行读写操作，即实现了网咯中不同进程之间的通信！网络I&#x2F;O操作有下面几组：</p>
<ul>
<li>read()&#x2F;write()</li>
<li>recv()&#x2F;send()</li>
<li>readv()&#x2F;writev()</li>
<li>recvmsg()&#x2F;sendmsg()*</li>
<li>recvfrom()&#x2F;sendto()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"> </span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"> </span><br><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</span><br><span class="line">const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</span><br><span class="line">struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line"> </span><br><span class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</span><br><span class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-4-1-read-函数"><a href="#3-4-1-read-函数" class="headerlink" title="3.4.1.read()函数"></a>3.4.1.read()函数</h4><p>$$<br>    read函数是负责从fd中读取内容<br>    \begin{cases}<br>        读成功：read返回实际所读字节数\<br>        读到文件末尾：返回值为0\	<br>        错误（&lt;0）:<br>        \begin{cases}<br>            EINTR:读是由中断引起;\<br>            ECONNREST:网络连接出了问题\<br>        \end{cases}<br>    \end{cases}<br>$$<br>$$<br>    write函数将buf中的nbytes字节内容写入文件描述符fd<br>    \begin{cases}<br>        写成功(返回值&gt;0)：表示写了部分或者是全部的数据\	<br>        错误(返回值&lt;0):返回-1，并设置errno变量<br>        \begin{cases}<br>            EINTR:在写的时候出现了中断错误;\<br>            EPIPE:网络连接出了问题(对方已经关闭了连接)\<br>        \end{cases}<br>    \end{cases}<br>$$</p>
<h3 id="3-6-close-函数"><a href="#3-6-close-函数" class="headerlink" title="3.6.close()函数"></a>3.6.close()函数</h3><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure>
<p>close一个TCP socket的缺省行为时把该 socket <u>标记为已关闭</u>，然后立即返回到调用进程。该描述字<strong>不能</strong>再由调用进程使用，也就是说<u>不能再作为read或write的第一个参数</u>。</p>
<p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求</p>
<h2 id="4-Socket中TCP的建立（三次握手）"><a href="#4-Socket中TCP的建立（三次握手）" class="headerlink" title="4.Socket中TCP的建立（三次握手）"></a>4.Socket中TCP的建立（三次握手）</h2><p>TCP协议通过三个报文段完成连接的建立</p>
<h3 id="4-1-TCP"><a href="#4-1-TCP" class="headerlink" title="4.1.TCP"></a>4.1.TCP</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ningdaxing1994/article/details/73076795">五分钟读懂TCP 协议——TCP协议简介-CSDN博客</a><br>TCP 协议的作用是，保证数据通信的<strong>完整性</strong>和<strong>可靠性</strong>，防止丢包</p>
<ul>
<li>TCP提供一个面向连接的、可靠的<strong>字节流服务</strong></li>
<li>在一个TCP连接中，仅有两方进行彼此通信(广播和多播不能用于TCP)</li>
<li>TCP 使用校验和，确认和重传机制来保证可靠传输<br> <font  size = 2 color='green'  >TCP 协议可以保证数据通信的完整性。 <br>
每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。<br>
(举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。)<br>
如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。</font></li>
<li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li>
<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>
<p>TCP并不能保证数据一定会被对方接收到，这是不可能的。<br>它不是100%可靠的协议，它所能提供的是<u>数据的可靠传递或故障的可靠通知。</u></p>
<h3 id="4-2-三次握手"><a href="#4-2-三次握手" class="headerlink" title="4.2.三次握手"></a>4.2.三次握手</h3><p><img src="/Socket/Pasted%20image%2020231106151100.png" alt="![[Pasted image 20231106151100.png]]"><br>三次握手，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包<br><img src="/Socket/Pasted%20image%2020231106172759.png" alt="![[Pasted image 20231106172759.png]]"><br>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；<br>服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；<br>客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；<br>服务器收到ACK K+1时，accept返回(一个已连接的socket描述字)，至此三次握手完毕，连接建立。</p>
<h4 id="4-2-1-三次握手"><a href="#4-2-1-三次握手" class="headerlink" title="4.2.1.三次握手"></a>4.2.1.三次握手</h4><h5 id="1-第一次握手（SYN）"><a href="#1-第一次握手（SYN）" class="headerlink" title="1) 第一次握手（SYN）"></a>1) 第一次握手（SYN）</h5><ul>
<li>客户端发送一个SYN<font size=2>(SYN：同步序列编号(Synchronize Sequence Numbers))</font>标志位的数据包 –&gt; 用于请求建立连接</li>
<li>客户端选择一个Seq<font size=2>(初始序列号)</font>&#x3D;x 放入数据包中</li>
<li>发送完毕后，<strong>客户端</strong>进入<strong>SYN_SEND</strong>状态</li>
</ul>
<h5 id="2-第二次握手（SYN-ACK）"><a href="#2-第二次握手（SYN-ACK）" class="headerlink" title="2)第二次握手（SYN-ACK）"></a>2)第二次握手（SYN-ACK）</h5><ul>
<li>服务器收到SYN数据包–&gt;发送一个带有 SYN 和 ACK<font size=2>(ACK：确认序列编号）</font>标志位的数据包(即[SYN, ACK])作为回应。</li>
<li>服务器选择一个Seq<font size=2>(初始序列号)</font>&#x3D;y 放入ACK数据包中 </li>
<li>服务器将客户端的SYN序列号+1(即x+1)，放入ACK数据包中–&gt;表示服务器已经收到客户端的请求，并准备好建立连接</li>
<li><strong>服务器</strong>进入<strong>SYN_RECV</strong>状态</li>
</ul>
<h5 id="3-第三次握手（ACK）"><a href="#3-第三次握手（ACK）" class="headerlink" title="3)第三次握手（ACK）"></a>3)第三次握手（ACK）</h5><ul>
<li>客户端接收服务器的SYN-ACK数据包–&gt;向服务器发送一个带有ACK标志位的数据包作为确认</li>
<li>将服务器端的ACK序列号+1(即y+1)，放入ACK数据包中–&gt;表示客户端确认服务器的回应–&gt;同意建立连接</li>
<li><code>客户端</code>发送完毕后，进入<code>ESTABLISHED</code>状态</li>
<li>服务器端收到客户端的ACK数据包–&gt;确认客户端的回应–&gt;连接建立成功</li>
<li><code>服务端</code>接收到这个包，也进入<code>ESTABLISHED</code>状态, TCP握手结束。</li>
</ul>
<p>通过三次握手，客户端和服务器彼此确认了对方的能力和准备就绪状态，建立了双向的通信连接。<br>每一次握手都需要对方的确认，确保连接的可靠性。</p>
<h4 id="4-2-2-SYN标志位"><a href="#4-2-2-SYN标志位" class="headerlink" title="4.2.2.SYN标志位"></a>4.2.2.SYN标志位</h4><ul>
<li>是TCP协议中的一个标志位,用于<strong>建立连接时进行通信的同步</strong>.</li>
<li>用于指示<code>发送方</code>希望<code>建立一个新的连接</code>或<code>确认一个连接请求</code></li>
</ul>
<p><strong>在TCP的三次握手过程中,SYN用于表示发送方发送了一个同步请求</strong></p>
<pre><code>当一个TCP客户端希望与服务器建立连接时，它会发送一个带有SYN标志位的数据包，称为SYN包。这个SYN包的作用是向服务器发起连接请求，并附带一个序列号（Sequence Number）。

服务器接收到客户端的SYN包后，会发送一个带有SYN和ACK（Acknowledgment）标志位的数据包作为回应，称为SYN-ACK包。这个SYN-ACK包中会包含服务器选择的一个初始序列号（ISN），作为服务器端的初始确认号（Acknowledgment Number）。

客户端再次收到服务器的SYN-ACK包后，会发送一个带有ACK标志位的数据包作为确认，称为ACK包。在这个ACK包中，客户端会确认服务器的SYN，并将服务器的 ISN + 1 后放入ACK包中，表示客户端确认服务器的回应，并同意建立连接。
</code></pre>
<p><strong>SYN标志位的使用:</strong><br>使TCP协议能够确保双方能够<strong>同步建立连接</strong>，并<strong>通过序列号的交换确保通信的可靠性</strong>。<br>是TCP三次握手过程中的关键步骤之一，用于<strong>确保连接的双向同步和建立连接的可靠性。</strong></p>
<h4 id="4-2-3-不可是两次握手"><a href="#4-2-3-不可是两次握手" class="headerlink" title="4.2.3.不可是两次握手"></a>4.2.3.不可是两次握手</h4><p>在标准的TCP协议中，建立连接需要进行三次握手，而不是两次握手。<br>三次握手过程提供了更强的连接可靠性和防止旧连接请求的保护。</p>
<p>只进行两次握手，可能会导致以下情况的发生：</p>
<p>1)<strong>数据包重复</strong>：<br>如果客户端发送的连接请求在网络中被延迟，在此期间该客户端重新发送相同的请求，<br>服务器收到两个相同的请求后会发送两个确认，导致建立了两个连接。<br>这种情况可能导致数据包重复和混乱。</p>
<p>2)<strong>旧连接请求的问题</strong>：<br>如果客户端发送了一个连接请求，但该请求在网络中被延迟并在一段时间后才到达服务器，服务器可能会误认为这是一个新的连接请求，从而建立连接。<br>这可能导致服务器与一个<code>已经关闭或过期的连接建立连接</code>，引发数据传输错误或安全问题。</p>
<p>第三次握手<u>允许服务器确认客户端的连接请求</u>，并<u>确保客户端已经收到了服务器的确认</u>。<br>这样可以避免旧连接请求的问题，并提供更可靠的连接建立机制。</p>
<h3 id="5-TCP连接的终止-四次挥手四次握手释放"><a href="#5-TCP连接的终止-四次挥手四次握手释放" class="headerlink" title="5.TCP连接的终止(四次挥手四次握手释放)"></a>5.TCP连接的终止(四次挥手<font size=2>四次握手释放</font>)</h3><p>终止一个连接要经过四次握手(发送四个包)，这是由TCP的半关闭(half-close)造成的<br><img src="/Socket/Pasted%20image%2020231107145105.png" alt="![[Pasted image 20231107145105.png]]"></p>
<ul>
<li>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。</li>
<li>这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。</li>
<li>收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。</li>
<li>首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</li>
</ul>
<h4 id="5-1-TCP四次挥手"><a href="#5-1-TCP四次挥手" class="headerlink" title="5.1.TCP四次挥手"></a>5.1.TCP四次挥手</h4><p><img src="/Socket/Pasted%20image%2020231107150503.png" alt="![[Pasted image 20231107150503.png]]"></p>
<h5 id="1）第一次挥手（-FIN-Seq-x）"><a href="#1）第一次挥手（-FIN-Seq-x）" class="headerlink" title="1）第一次挥手（[FIN], Seq &#x3D; x）"></a>1）第一次挥手（[FIN], Seq &#x3D; x）</h5><ul>
<li>客户端发送一个FIN标记的包，告诉服务器需要关闭连接，表示自己不用发送数据，但还可以接收数据。</li>
<li>发送完成后，<code>客户端</code>进入<code>FIN_WAIT_1</code>状态。</li>
</ul>
<h5 id="2）第二次挥手-ACK-ACK-x-1"><a href="#2）第二次挥手-ACK-ACK-x-1" class="headerlink" title="2）第二次挥手 ([ACK], ACK &#x3D; x + 1)"></a>2）第二次挥手 <strong>([ACK], ACK &#x3D; x + 1)</strong></h5><ul>
<li>服务端收到FIN，发送一个ACK的确认包(确认序号为收到的序号+1)，告诉客户端接收到关闭请求，但是还未准备好。</li>
<li>发送完成后，<code>服务端</code>进入<code>CLOSE_WAIT</code>状态，</li>
<li><code>客户端</code>收到这个包后，进入<code>FIN_WAIT_2</code>，等待服务器关闭连接。</li>
</ul>
<h5 id="3）第三次挥手-FIN-Seq-y"><a href="#3）第三次挥手-FIN-Seq-y" class="headerlink" title="3）第三次挥手 ([FIN], Seq &#x3D; y)"></a>3）第三次挥手 ([FIN], Seq &#x3D; y)</h5><ul>
<li>服务端准备好关闭连接后，发送FIN标记的包，告诉客户端准备关闭。</li>
<li>发送完成后，<code>服务端</code>进入<code>LAST_ACK</code>状态，等待客户端确认。</li>
</ul>
<h5 id="4）第四次挥手-ACK-ACK-y-1"><a href="#4）第四次挥手-ACK-ACK-y-1" class="headerlink" title="4）第四次挥手 ([ACK], ACK &#x3D; y + 1)"></a>4）第四次挥手 ([ACK], ACK &#x3D; y + 1)</h5><ul>
<li><p>客户端接收到服务端的关闭请求，再发送ACK标记的确认包，进入<code>TIME_WAIT</code>状态，等待服务端可能请求重传的ACK包。<br><font color='green'>为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</font></p>
<p>  这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；</p>
<p>  但是因为我们<strong>必须要假想网络是不可靠的</strong>，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</p>
</li>
<li><p>服务端接收到ACK包后，关闭连接，进入<code>CLOSED</code>状态。</p>
</li>
<li><p>客户端在*等待固定时间(两个最大段生命周期)*后，没有接收到服务的ACK包，认为服务器已关闭连接，自己也关闭连接，进入<code>CLOSED</code>状态。</p>
</li>
</ul>
<h4 id="5-2不能三次挥手"><a href="#5-2不能三次挥手" class="headerlink" title="5.2不能三次挥手"></a>5.2不能三次挥手</h4><p>从假设的角度分析，如果是三次挥手，在服务器接收到客户端发送关闭的请求后，把SYN和ACK包一起发过去。</p>
<p>这样<u>会造成服务端还有数据没有发送完，造成了数据的丢失。</u><br>所以中间的这一段时间，等待服务器把剩余的数据发送完是很有必要的。</p>
<h4 id="5-3-重要字段"><a href="#5-3-重要字段" class="headerlink" title="5.3.重要字段"></a>5.3.重要字段</h4><p>**序号(sequence number)**：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p>
<p><strong>确认号（acknowledgement number）</strong>：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack&#x3D;seq+1。</p>
<p><strong>标志位（Flags）</strong>：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：</p>
<p><strong>URG</strong>：紧急指针（urgent pointer）有效。</p>
<p><strong>ACK</strong>：确认序号有效。（为了与确认号ack区分开，我们用大写表示）</p>
<p><strong>PSH</strong>：接收方应该尽快将这个报文交给应用层。</p>
<p><strong>RST</strong>：重置连接。</p>
<p><strong>SYN</strong>：发起一个新连接。</p>
<p><strong>FIN</strong>：释放一个连接。</p>
<ul>
<li>seq序号、ack序号：用于确认数据是否准确，是否正常通信。</li>
<li>标志位：用于确认&#x2F;更改连接状态。<br><img src="/Socket/Pasted%20image%2020231108214814.png" alt="![[Pasted image 20231108214814.png]]"><strong>SYN</strong>：用于<strong>建立连接</strong>。</li>
</ul>
<p><strong>ACK</strong>：用于确定<strong>收到了请求</strong>。</p>
<p><strong>seq</strong>：发送<strong>自己的</strong>数据。</p>
<p><strong>ack</strong>：发送<strong>接收到的对方的</strong>数据。</p>
<h2 id="6、实例"><a href="#6、实例" class="headerlink" title="6、实例"></a>6、实例</h2><h2 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h2><h3 id="1、IPv4地址"><a href="#1、IPv4地址" class="headerlink" title="1、IPv4地址"></a>1、IPv4地址</h3><ul>
<li>目前全球因特网所采用的协议族是TCP&#x2F;IP协议。IP是TCP&#x2F;IP协议中网络层的协议，是TCP&#x2F;IP协议族的核心协议。</li>
<li>目前主要采用的 IP 协议的版本号是 4 (简称为 IPv4)</li>
<li>IPv4 的地址位数为 32 位，也就是最多有 2 的 32 次方的网络设备可以联到 Internet 上。</li>
<li>地址格式类似这样：127.0.0.1 172.122.121.111</li>
</ul>
<h3 id="2、IPv6地址"><a href="#2、IPv6地址" class="headerlink" title="2、IPv6地址"></a>2、IPv6地址</h3><ul>
<li>下一版本的互联网协议</li>
<li>为解决IPv4在实施过程中遇到的各种问题而被提出</li>
<li>采用128为地址长度，几乎可以不受限制地提供地址。</li>
<li>解决了地址短缺问题，考虑了IPv4中解决不好的其他问题：端到端IP连接、服务质量(QoS)、安全性、多播、移动性、即插即用等。</li>
<li><strong>IPv6地址总长度为128位，通常分为8组，每组为4个十六进制数的形式，每组十六进制数间用冒号分隔</strong></li>
<li>e.g.FC00:0000:130F:0000:0000 :09C0:876A:130B</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/socket/" rel="tag"># socket</a>
              <a href="/tags/TCP/" rel="tag"># TCP</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/07/09/About-Gin/" rel="prev" title="About Gin">
                  <i class="fa fa-angle-left"></i> About Gin
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">MandyX</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
